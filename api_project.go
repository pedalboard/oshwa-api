/*
OSHWA API

# Introduction  Welcome to the OSHWA Open Source Hardware Certification API. We hope that you will use it to build on top of the OSHWA certification program. This documentation provides information on how to use the OSHWA REST API to view, create, and search OSHWA certified open source hardware projects. You can learn more about OSHWA [here](https://www.oshwa.org/about/) and more about OSHWA’s free open source hardware certification program [here](https://certification.oshwa.org/).  This API supports both read and write functions. You can use the read functions to pull information about certified hardware from the [directory](https://certification.oshwa.org/list.html) in order to explore and present it in new ways. We encourage you to use it to find new ways to understand and visualize the world of open source hardware!  You can use the write functions to make it easier to submit registration applications to the program. Originally, the only way to submit hardware for registration was through OSHWA’s [application form](https://application.oshwa.org/apply). We hope that the write functionality will make it easier to integrate certification applications into existing workflows, and to connect platforms that already host open source hardware to the certification program.    If you have questions or comments about the API, please email us at info@oshwa.org.  We would also love to know how you use the API! We encourage you to contact us at info@oshwa.org, or let us know on twitter at @OHSummit.  # Tools This API is documented in **OpenAPI format**. It is built with [Swagger](http://swagger.io) and [ReDoc](https://github.com/Redocly/redoc).  # Using the API In order to use the API, you must register for an API key. You can get your own API key [here](https://certificationapi.oshwa.org/). If your token is not included or is invalid, the API will return an error. If you'd like to test the endpoints, check out our [Swagger](/endpoints) implementation, where you will be able to request a key, add the key to your requests, and explore OSHWA certified projects. You will also find code examples in this documentation.  # Pagination Project and Company results are returned in a wrapper object that contains total, limit, and offset values, which are useful for paginating over results.   ``` {   \"total\": 200, // Total number of matching items   \"offset\": 0, // Number of items skipped in request   \"limit\": 100, // Max number of items in request   \"items\": [ {...} ] // List of items } ```  The default `limit` for requests is 100, and the maximum `limit` is 1000. The default `offset` is 0. The above request returns the first 100 items. To get the next 100 items, the `offset` would be changed to 100. These parameters can be used to loop through the api and retrieve all items.  All items are returned in alphabetical order by `projectName`.   # Authentication  All OSHWA API endpoints require Bearer Token Authentication.  You can get an API key [here](https://certificationapi.oshwa.org/).  # Errors  The OSHWA API uses HTTP response status codes to indicate whether the response was successful. Detailed information about the response and how any errors might be resolved can be found in the body of the error message.  ``` {     \"error\": {         \"statusCode\": 422,         \"errorCode\": \"Unprocessable Entity\",         \"message\": \"Validation Error: Input validation failed\",         \"details\": [             {                 \"msg\": \"Responsible Party Type is required\",                 \"param\": \"responsiblePartyType\",                 \"location\": \"body\"             },         ]     } } ``` 

API version: 1.0.0
Contact: 
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ProjectAPIService ProjectAPI service
type ProjectAPIService service

type ApiApiProjectsGetRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	q *string
	types *string
	oshwaUid *string
	projectName *string
	country *string
	primaryType *string
	additionalType *[]string
	projectKeywords *[]string
	hardwareLicense *string
	softWareLicense *string
	documentationLicense *string
	limit *int32
	offset *int32
}

// Full text search across project text fields
func (r ApiApiProjectsGetRequest) Q(q string) ApiApiProjectsGetRequest {
	r.q = &q
	return r
}

// Returns matches in primaryType, additionalType, or projectKeywords. Multiple types can be searched with comma-separated values, i.e. &#x60;arts,education,electronics&#x60;
func (r ApiApiProjectsGetRequest) Types(types string) ApiApiProjectsGetRequest {
	r.types = &types
	return r
}

// OSHWA UID
func (r ApiApiProjectsGetRequest) OshwaUid(oshwaUid string) ApiApiProjectsGetRequest {
	r.oshwaUid = &oshwaUid
	return r
}

// Project Name
func (r ApiApiProjectsGetRequest) ProjectName(projectName string) ApiApiProjectsGetRequest {
	r.projectName = &projectName
	return r
}

// Country
func (r ApiApiProjectsGetRequest) Country(country string) ApiApiProjectsGetRequest {
	r.country = &country
	return r
}

// Primary Type
func (r ApiApiProjectsGetRequest) PrimaryType(primaryType string) ApiApiProjectsGetRequest {
	r.primaryType = &primaryType
	return r
}

// Additional Type
func (r ApiApiProjectsGetRequest) AdditionalType(additionalType []string) ApiApiProjectsGetRequest {
	r.additionalType = &additionalType
	return r
}

// Project Keywords
func (r ApiApiProjectsGetRequest) ProjectKeywords(projectKeywords []string) ApiApiProjectsGetRequest {
	r.projectKeywords = &projectKeywords
	return r
}

// Hardware License
func (r ApiApiProjectsGetRequest) HardwareLicense(hardwareLicense string) ApiApiProjectsGetRequest {
	r.hardwareLicense = &hardwareLicense
	return r
}

// Software License
func (r ApiApiProjectsGetRequest) SoftWareLicense(softWareLicense string) ApiApiProjectsGetRequest {
	r.softWareLicense = &softWareLicense
	return r
}

// Documentation License
func (r ApiApiProjectsGetRequest) DocumentationLicense(documentationLicense string) ApiApiProjectsGetRequest {
	r.documentationLicense = &documentationLicense
	return r
}

// The number of items to return. Default is 100, maximum is 1000
func (r ApiApiProjectsGetRequest) Limit(limit int32) ApiApiProjectsGetRequest {
	r.limit = &limit
	return r
}

// The number of records to skip when retrieving results
func (r ApiApiProjectsGetRequest) Offset(offset int32) ApiApiProjectsGetRequest {
	r.offset = &offset
	return r
}

func (r ApiApiProjectsGetRequest) Execute() (*PublicProjects, *http.Response, error) {
	return r.ApiService.ApiProjectsGetExecute(r)
}

/*
ApiProjectsGet Get all OSHWA certified projects

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiProjectsGetRequest
*/
func (a *ProjectAPIService) ApiProjectsGet(ctx context.Context) ApiApiProjectsGetRequest {
	return ApiApiProjectsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PublicProjects
func (a *ProjectAPIService) ApiProjectsGetExecute(r ApiApiProjectsGetRequest) (*PublicProjects, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PublicProjects
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiProjectsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.types != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "types", r.types, "form", "")
	}
	if r.oshwaUid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "oshwaUid", r.oshwaUid, "form", "")
	}
	if r.projectName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "projectName", r.projectName, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.primaryType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "primaryType", r.primaryType, "form", "")
	}
	if r.additionalType != nil {
		t := *r.additionalType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "additionalType", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "additionalType", t, "form", "multi")
		}
	}
	if r.projectKeywords != nil {
		t := *r.projectKeywords
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "projectKeywords", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "projectKeywords", t, "form", "multi")
		}
	}
	if r.hardwareLicense != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hardwareLicense", r.hardwareLicense, "form", "")
	}
	if r.softWareLicense != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "softWare License", r.softWareLicense, "form", "")
	}
	if r.documentationLicense != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "documentationLicense", r.documentationLicense, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiProjectsIdGetRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	id string
}

func (r ApiApiProjectsIdGetRequest) Execute() (*PublicProject, *http.Response, error) {
	return r.ApiService.ApiProjectsIdGetExecute(r)
}

/*
ApiProjectsIdGet Get an OSHWA certified project by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiApiProjectsIdGetRequest
*/
func (a *ProjectAPIService) ApiProjectsIdGet(ctx context.Context, id string) ApiApiProjectsIdGetRequest {
	return ApiApiProjectsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PublicProject
func (a *ProjectAPIService) ApiProjectsIdGetExecute(r ApiApiProjectsIdGetRequest) (*PublicProject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PublicProject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiProjectsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiProjectsPostRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	project *Project
}

func (r ApiApiProjectsPostRequest) Project(project Project) ApiApiProjectsPostRequest {
	r.project = &project
	return r
}

func (r ApiApiProjectsPostRequest) Execute() (*ApiProjectsPost200Response, *http.Response, error) {
	return r.ApiService.ApiProjectsPostExecute(r)
}

/*
ApiProjectsPost Create a project for OSHWA certification

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiProjectsPostRequest
*/
func (a *ProjectAPIService) ApiProjectsPost(ctx context.Context) ApiApiProjectsPostRequest {
	return ApiApiProjectsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiProjectsPost200Response
func (a *ProjectAPIService) ApiProjectsPostExecute(r ApiApiProjectsPostRequest) (*ApiProjectsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiProjectsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiProjectsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.project == nil {
		return localVarReturnValue, nil, reportError("project is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.project
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
